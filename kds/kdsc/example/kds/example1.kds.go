// Code generated by kds. DO NOT EDIT.
// source: TODO: Source File

package kds;

import (
	"time"

	"github.com/iakud/keeper/kds/kdsc/example/pb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/durationpb"
)

type Player struct {
	id int64
	info *PlayerBasicInfo
	hero *PlayerHero
	bag *PlayerBag

	dirty uint64
}

func NewPlayer() *Player {
	x := new(Player)
	x.dirty = 1
	x.id = 0 // FIXME: gen nextId()
	x.setInfo(NewPlayerBasicInfo())
	x.setHero(NewPlayerHero())
	x.setBag(NewPlayerBag())
	return x
}

func (x *Player) GetId() int64 {
	return x.id
}


func (x *Player) GetInfo() *PlayerBasicInfo {
	return x.info
}

func (x *Player) setInfo(v *PlayerBasicInfo) {
	if v != x.info {
		x.info = v
		v.dirthParent = func() {
			x.markDirty(uint64(0x01) << 1)
		}
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *Player) GetHero() *PlayerHero {
	return x.hero
}

func (x *Player) setHero(v *PlayerHero) {
	if v != x.hero {
		x.hero = v
		v.dirthParent = func() {
			x.markDirty(uint64(0x01) << 2)
		}
		x.markDirty(uint64(0x01) << 2)
	}
}

func (x *Player) GetBag() *PlayerBag {
	return x.bag
}

func (x *Player) setBag(v *PlayerBag) {
	if v != x.bag {
		x.bag = v
		v.dirthParent = func() {
			x.markDirty(uint64(0x01) << 3)
		}
		x.markDirty(uint64(0x01) << 3)
	}
}

func (x *Player) DumpChange() *pb.Player {
	m := new(pb.Player)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Info = x.info.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.Hero = x.hero.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.Bag = x.bag.DumpChange()
	}
	return m
}

func (x *Player) DumpFull() *pb.Player {
	m := new(pb.Player)
	m.Info = x.info.DumpFull()
	m.Hero = x.hero.DumpFull()
	m.Bag = x.bag.DumpFull()
	return m
}

func (x *Player) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
}

func (x *Player) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
	x.info.clearDirty()
	x.hero.clearDirty()
	x.bag.clearDirty()
}

func (x *Player) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_PlayerBasicInfo func()

func (f dirtyParentFunc_PlayerBasicInfo) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBasicInfo struct {
	name string
	isNew bool
	createTime time.Time

	dirty uint64
	dirthParent dirtyParentFunc_PlayerBasicInfo
}

func NewPlayerBasicInfo() *PlayerBasicInfo {
	x := new(PlayerBasicInfo)
	x.dirty = 1
	return x
}


func (x *PlayerBasicInfo) GetName() string {
	return x.name
}

func (x *PlayerBasicInfo) SetName(v string) {
	if v != x.name {
		x.name = v
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *PlayerBasicInfo) GetIsNew() bool {
	return x.isNew
}

func (x *PlayerBasicInfo) SetIsNew(v bool) {
	if v != x.isNew {
		x.isNew = v
		x.markDirty(uint64(0x01) << 3)
	}
}

func (x *PlayerBasicInfo) GetCreateTime() time.Time {
	return x.createTime
}

func (x *PlayerBasicInfo) SetCreateTime(v time.Time) {
	if v != x.createTime {
		x.createTime = v
		x.markDirty(uint64(0x01) << 5)
	}
}

func (x *PlayerBasicInfo) DumpChange() *pb.PlayerBasicInfo {
	m := new(pb.PlayerBasicInfo)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Name = x.name
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.IsNew = x.isNew
	}
	if x.checkDirty(uint64(0x01) << 5) {
		m.CreateTime = timestamppb.New(x.createTime)
	}
	return m
}

func (x *PlayerBasicInfo) DumpFull() *pb.PlayerBasicInfo {
	m := new(pb.PlayerBasicInfo)
	m.Name = x.name
	m.IsNew = x.isNew
	m.CreateTime = timestamppb.New(x.createTime)
	return m
}

func (x *PlayerBasicInfo) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *PlayerBasicInfo) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

func (x *PlayerBasicInfo) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_PlayerHero func()

func (f dirtyParentFunc_PlayerHero) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerHero struct {
	heroes map[int64]*Hero

	dirty uint64
	dirthParent dirtyParentFunc_PlayerHero
}

func NewPlayerHero() *PlayerHero {
	x := new(PlayerHero)
	x.dirty = 1
	x.heroes = make(map[int64]*Hero)
	return x
}


func (x *PlayerHero) DumpChange() *pb.PlayerHero {
	m := new(pb.PlayerHero)
	if x.checkDirty(uint64(0x01) << 1) {
		for k, v := range x.heroes {
			m.Heroes[k] = v.DumpChange()
		}
	}
	return m
}

func (x *PlayerHero) DumpFull() *pb.PlayerHero {
	m := new(pb.PlayerHero)
	for k, v := range x.heroes {
		m.Heroes[k] = v.DumpFull()
	}
	return m
}

func (x *PlayerHero) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *PlayerHero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
	for _, v := range x.heroes {
		v.clearDirty()
	}
}

func (x *PlayerHero) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_PlayerBag func()

func (f dirtyParentFunc_PlayerBag) invoke() {
	if f == nil {
		return
	}
	f()
}

type PlayerBag struct {
	resources map[int32]int32

	dirty uint64
	dirthParent dirtyParentFunc_PlayerBag
}

func NewPlayerBag() *PlayerBag {
	x := new(PlayerBag)
	x.dirty = 1
	x.resources = make(map[int32]int32)
	return x
}


func (x *PlayerBag) DumpChange() *pb.PlayerBag {
	m := new(pb.PlayerBag)
	if x.checkDirty(uint64(0x01) << 1) {
		for k, v := range x.resources {
			m.Resources[k] = v
		}
	}
	return m
}

func (x *PlayerBag) DumpFull() *pb.PlayerBag {
	m := new(pb.PlayerBag)
	for k, v := range x.resources {
		m.Resources[k] = v
	}
	return m
}

func (x *PlayerBag) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *PlayerBag) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

func (x *PlayerBag) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_Hero func()

func (f dirtyParentFunc_Hero) invoke() {
	if f == nil {
		return
	}
	f()
}

type Hero struct {
	heroId int32
	heroLevel int32
	_type HeroType
	needTime time.Duration

	dirty uint64
	dirthParent dirtyParentFunc_Hero
}

func NewHero() *Hero {
	x := new(Hero)
	x.dirty = 1
	return x
}


func (x *Hero) GetHeroId() int32 {
	return x.heroId
}

func (x *Hero) SetHeroId(v int32) {
	if v != x.heroId {
		x.heroId = v
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *Hero) GetHeroLevel() int32 {
	return x.heroLevel
}

func (x *Hero) SetHeroLevel(v int32) {
	if v != x.heroLevel {
		x.heroLevel = v
		x.markDirty(uint64(0x01) << 2)
	}
}

func (x *Hero) GetType() HeroType {
	return x._type
}

func (x *Hero) SetType(v HeroType) {
	if v != x._type {
		x._type = v
		x.markDirty(uint64(0x01) << 3)
	}
}

func (x *Hero) GetNeedTime() time.Duration {
	return x.needTime
}

func (x *Hero) SetNeedTime(v time.Duration) {
	if v != x.needTime {
		x.needTime = v
		x.markDirty(uint64(0x01) << 4)
	}
}

func (x *Hero) DumpChange() *pb.Hero {
	m := new(pb.Hero)
	if x.checkDirty(uint64(0x01) << 1) {
		m.HeroId = x.heroId
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.HeroLevel = x.heroLevel
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.Type = x._type
	}
	if x.checkDirty(uint64(0x01) << 4) {
		m.NeedTime = durationpb.New(x.needTime)
	}
	return m
}

func (x *Hero) DumpFull() *pb.Hero {
	m := new(pb.Hero)
	m.HeroId = x.heroId
	m.HeroLevel = x.heroLevel
	m.Type = x._type
	m.NeedTime = durationpb.New(x.needTime)
	return m
}

func (x *Hero) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *Hero) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

func (x *Hero) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type HeroType = pb.HeroType

const (
	HeroType_HeroType1 HeroType = 0
	HeroType_HeroType2 HeroType = 2
	HeroType_HeroType3 HeroType = -5
)