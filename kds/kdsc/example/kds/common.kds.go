// Code generated by kds. DO NOT EDIT.
// source: TODO: Source File

package kds;
import (
	"iter"
	"maps"
	"slices"

	"google.golang.org/protobuf/types/known/emptypb"
)

type dirtyParentFunc_Int32_Empty_Map func()

func (f dirtyParentFunc_Int32_Empty_Map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32_Empty_Map struct {
	syncable map[int32]struct{}

	dirty map[int32]struct{}
	dirtyParent dirtyParentFunc_Int32_Empty_Map
}

func (x *Int32_Empty_Map) Len() int {
	return len(x.syncable)
}

func (x *Int32_Empty_Map) Clear() {
	clear(x.syncable)
}

func (x *Int32_Empty_Map) Get(k int32) (struct{}, bool) {
	v, ok := x.syncable[k]
	return v, ok
}

func (x *Int32_Empty_Map) Set(k int32, v struct{}) {
	x.syncable[k] = v
}

func (x *Int32_Empty_Map) Delete(k int32) {
	delete(x.syncable, k)
}

func (x *Int32_Empty_Map) All() iter.Seq2[int32, struct{}] {
	return maps.All(x.syncable)
}

func (x *Int32_Empty_Map) Keys() iter.Seq[int32] {
	return maps.Keys(x.syncable)
}

func (x *Int32_Empty_Map) Values() iter.Seq[struct{}] {
	return maps.Values(x.syncable)
}

func (x *Int32_Empty_Map) DumpChange() map[int32]*emptypb.Empty {
	m := make(map[int32]*emptypb.Empty)
	for k := range x.syncable {
		m[k] = new(emptypb.Empty)
	}
	return m
}

func (x *Int32_Empty_Map) DumpFull() map[int32]*emptypb.Empty {
	m := make(map[int32]*emptypb.Empty)
	for k := range x.syncable {
		m[k] = new(emptypb.Empty)
	}
	return m
}

func (x *Int32_Empty_Map) markDirty(k int32) {
	_ = k
	x.dirtyParent.invoke()
}

func (x *Int32_Empty_Map) clearDirty() {
}

type dirtyParentFunc_Int32_Int32_Map func()

func (f dirtyParentFunc_Int32_Int32_Map) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int32_Int32_Map struct {
	syncable map[int32]int32

	dirty map[int32]int32
	dirtyParent dirtyParentFunc_Int32_Int32_Map
}

func (x *Int32_Int32_Map) Len() int {
	return len(x.syncable)
}

func (x *Int32_Int32_Map) Clear() {
	clear(x.syncable)
}

func (x *Int32_Int32_Map) Get(k int32) (int32, bool) {
	v, ok := x.syncable[k]
	return v, ok
}

func (x *Int32_Int32_Map) Set(k int32, v int32) {
	x.syncable[k] = v
}

func (x *Int32_Int32_Map) Delete(k int32) {
	delete(x.syncable, k)
}

func (x *Int32_Int32_Map) All() iter.Seq2[int32, int32] {
	return maps.All(x.syncable)
}

func (x *Int32_Int32_Map) Keys() iter.Seq[int32] {
	return maps.Keys(x.syncable)
}

func (x *Int32_Int32_Map) Values() iter.Seq[int32] {
	return maps.Values(x.syncable)
}

func (x *Int32_Int32_Map) DumpChange() map[int32]int32 {
	m := make(map[int32]int32)
	for k, v := range x.syncable {
		m[k] = v
	}
	return m
}

func (x *Int32_Int32_Map) DumpFull() map[int32]int32 {
	m := make(map[int32]int32)
	for k, v := range x.syncable {
		m[k] = v
	}
	return m
}

func (x *Int32_Int32_Map) markDirty(k int32) {
	_ = k
	x.dirtyParent.invoke()
}

func (x *Int32_Int32_Map) clearDirty() {
}

type dirtyParentFunc_Int64_List func()

func (f dirtyParentFunc_Int64_List) invoke() {
	if f == nil {
		return
	}
	f()
}

type Int64_List struct {
	syncable []int64

	dirtyParent dirtyParentFunc_Int64_List
}

func (x *Int64_List) Len() int {
	return len(x.syncable)
}

func (x *Int64_List) Get(i int) int64 {
	return x.syncable[i]
}

func (x *Int64_List) Set(i int, v int64) {
	x.syncable[i] = v
}

func (x *Int64_List) Append(v ...int64) {
	x.syncable = append(x.syncable, v...)
}

func (x *Int64_List) Insert(i int, v ...int64) {
	x.syncable = slices.Insert(x.syncable, i, v...)
}

func (x *Int64_List) Delete(i, j int) {
	x.syncable = slices.Delete(x.syncable, i, j)
}

func (x *Int64_List) Replace(i, j int, v ...int64) {
	x.syncable = slices.Replace(x.syncable, i, j, v...)
}

func (x *Int64_List) Reverse() {
	slices.Reverse(x.syncable)
}

func (x *Int64_List) All() iter.Seq2[int, int64] {
	return slices.All(x.syncable)
}

func (x *Int64_List) Backward() iter.Seq2[int, int64] {
	return slices.Backward(x.syncable)
}

func (x *Int64_List) Values() iter.Seq[int64] {
	return slices.Values(x.syncable)
}

func (x *Int64_List) DumpChange() []int64 {
	return x.DumpFull()
}

func (x *Int64_List) DumpFull() []int64 {
	var m []int64
	for _, v := range x.syncable {
		m = append(m, v)
	}
	return m
}

func (x *Int64_List) markDirty() {
	x.dirtyParent.invoke()
}

func (x *Int64_List) clearDirty() {
}