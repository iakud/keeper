// Code generated by kds. DO NOT EDIT.
// source: TODO: Source File

package kds;

import (
	"github.com/iakud/keeper/kds/kdsc/example/pb"
)

type City struct {
	id int64
	playerId int64
	playerBasicInfo *PlayerBasicInfo
	cityInfo *CityBaseInfo

	dirty uint64
}

func NewCity() *City {
	x := new(City)
	x.dirty = 1
	x.id = 0 // FIXME: gen nextId()
	x.setPlayerBasicInfo(NewPlayerBasicInfo())
	x.setCityInfo(NewCityBaseInfo())
	return x
}

func (x *City) GetId() int64 {
	return x.id
}


func (x *City) GetPlayerId() int64 {
	return x.playerId
}

func (x *City) SetPlayerId(v int64) {
	if v != x.playerId {
		x.playerId = v
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *City) GetPlayerBasicInfo() *PlayerBasicInfo {
	return x.playerBasicInfo
}

func (x *City) setPlayerBasicInfo(v *PlayerBasicInfo) {
	if v != x.playerBasicInfo {
		x.playerBasicInfo = v
		v.dirthParent = func() {
			x.markDirty(uint64(0x01) << 2)
		}
		x.markDirty(uint64(0x01) << 2)
	}
}

func (x *City) GetCityInfo() *CityBaseInfo {
	return x.cityInfo
}

func (x *City) setCityInfo(v *CityBaseInfo) {
	if v != x.cityInfo {
		x.cityInfo = v
		v.dirthParent = func() {
			x.markDirty(uint64(0x01) << 3)
		}
		x.markDirty(uint64(0x01) << 3)
	}
}

func (x *City) DumpChange() *pb.City {
	m := new(pb.City)
	if x.checkDirty(uint64(0x01) << 1) {
		m.PlayerId = x.playerId
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.PlayerBasicInfo = x.playerBasicInfo.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.CityInfo = x.cityInfo.DumpChange()
	}
	return m
}

func (x *City) DumpFull() *pb.City {
	m := new(pb.City)
	m.PlayerId = x.playerId
	m.PlayerBasicInfo = x.playerBasicInfo.DumpFull()
	m.CityInfo = x.cityInfo.DumpFull()
	return m
}

func (x *City) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
}

func (x *City) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
	x.playerBasicInfo.clearDirty()
	x.cityInfo.clearDirty()
}

func (x *City) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_CityBaseInfo func()

func (f dirtyParentFunc_CityBaseInfo) invoke() {
	if f == nil {
		return
	}
	f()
}

type CityBaseInfo struct {
	positions []*Vector

	dirty uint64
	dirthParent dirtyParentFunc_CityBaseInfo
}

func NewCityBaseInfo() *CityBaseInfo {
	x := new(CityBaseInfo)
	x.dirty = 1
	return x
}


func (x *CityBaseInfo) DumpChange() *pb.CityBaseInfo {
	m := new(pb.CityBaseInfo)
	if x.checkDirty(uint64(0x01) << 1) {
		for _, v := range x.positions {
			m.Positions = append(m.Positions, v.DumpChange())
		}
	}
	return m
}

func (x *CityBaseInfo) DumpFull() *pb.CityBaseInfo {
	m := new(pb.CityBaseInfo)
	for _, v := range x.positions {
		m.Positions = append(m.Positions, v.DumpFull())
	}
	return m
}

func (x *CityBaseInfo) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *CityBaseInfo) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
	for _, v := range x.positions {
		v.clearDirty()
	}
}

func (x *CityBaseInfo) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_Vector func()

func (f dirtyParentFunc_Vector) invoke() {
	if f == nil {
		return
	}
	f()
}

type Vector struct {
	x int32
	y int32

	dirty uint64
	dirthParent dirtyParentFunc_Vector
}

func NewVector() *Vector {
	x := new(Vector)
	x.dirty = 1
	return x
}


func (x *Vector) GetX() int32 {
	return x.x
}

func (x *Vector) SetX(v int32) {
	if v != x.x {
		x.x = v
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *Vector) GetY() int32 {
	return x.y
}

func (x *Vector) SetY(v int32) {
	if v != x.y {
		x.y = v
		x.markDirty(uint64(0x01) << 2)
	}
}

func (x *Vector) DumpChange() *pb.Vector {
	m := new(pb.Vector)
	if x.checkDirty(uint64(0x01) << 1) {
		m.X = x.x
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.Y = x.y
	}
	return m
}

func (x *Vector) DumpFull() *pb.Vector {
	m := new(pb.Vector)
	m.X = x.x
	m.Y = x.y
	return m
}

func (x *Vector) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirthParent.invoke()
}

func (x *Vector) clearDirty() {
	if x.dirty == 0 {
		return
	}
	x.dirty = 0
}

func (x *Vector) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}