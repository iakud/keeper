// Code generated by kds. DO NOT EDIT.
// source: example2.kds

package kds;

import (
	"iter"
	"slices"

	"github.com/iakud/krocher/kds/kdsc/example/kdspb"
)

type syncableCity struct {
	PlayerId int64
	PlayerBasicInfo *PlayerBasicInfo
	CityInfo *CityBaseInfo
	Troops Int64_List
}

type City struct {
	id int64
	syncable syncableCity

	dirty uint64
}

func NewCity() *City {
	x := new(City)
	x.dirty = 1
	x.id = 0 // FIXME: gen nextId()
	x.setPlayerBasicInfo(NewPlayerBasicInfo())
	x.setCityInfo(NewCityBaseInfo())
	x.initTroops()
	return x
}

func (x *City) Id() int64 {
	return x.id
}

func (x *City) GetPlayerId() int64 {
	return x.syncable.PlayerId
}

func (x *City) SetPlayerId(v int64) {
	if v == x.syncable.PlayerId {
		return
	}
	x.syncable.PlayerId = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *City) GetPlayerBasicInfo() *PlayerBasicInfo {
	return x.syncable.PlayerBasicInfo
}

func (x *City) setPlayerBasicInfo(v *PlayerBasicInfo) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable.PlayerBasicInfo {
		return
	}
	if x.syncable.PlayerBasicInfo != nil {
		x.syncable.PlayerBasicInfo.dirtyParent = nil
	}
	x.syncable.PlayerBasicInfo = v
	v.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 2)
	}
	x.markDirty(uint64(0x01) << 2)
	if v != nil {
		v.markDirty(uint64(0x01))
	}
}

func (x *City) GetCityInfo() *CityBaseInfo {
	return x.syncable.CityInfo
}

func (x *City) setCityInfo(v *CityBaseInfo) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable.CityInfo {
		return
	}
	if x.syncable.CityInfo != nil {
		x.syncable.CityInfo.dirtyParent = nil
	}
	x.syncable.CityInfo = v
	v.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 3)
	}
	x.markDirty(uint64(0x01) << 3)
	if v != nil {
		v.markDirty(uint64(0x01))
	}
}

func (x *City) GetTroops() *Int64_List {
	return &x.syncable.Troops
}

func (x *City) initTroops() {
	x.syncable.Troops.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 4)
	}
}

func (x *City) DumpChange() *kdspb.City {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.City)
	if x.checkDirty(uint64(0x01) << 1) {
		m.PlayerId = x.syncable.PlayerId
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.PlayerBasicInfo = x.syncable.PlayerBasicInfo.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.CityInfo = x.syncable.CityInfo.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 4) {
		m.Troops = x.syncable.Troops.DumpChange()
	}
	return m
}

func (x *City) DumpFull() *kdspb.City {
	m := new(kdspb.City)
	m.PlayerId = x.syncable.PlayerId
	m.PlayerBasicInfo = x.syncable.PlayerBasicInfo.DumpFull()
	m.CityInfo = x.syncable.CityInfo.DumpFull()
	m.Troops = x.syncable.Troops.DumpFull()
	return m
}

func (x *City) markAll() {
	x.dirty = uint64(0x01)
}

func (x *City) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
}

func (x *City) clearAll() {
	x.syncable.PlayerBasicInfo.clearDirty()
	x.syncable.CityInfo.clearDirty()
	x.syncable.Troops.clearDirty()
	x.dirty = 0
}

func (x *City) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	if x.dirty & uint64(0x01) << 2 != 0 {
		x.syncable.PlayerBasicInfo.clearDirty()
	}
	if x.dirty & uint64(0x01) << 3 != 0 {
		x.syncable.CityInfo.clearDirty()
	}
	if x.dirty & uint64(0x01) << 4 != 0 {
		x.syncable.Troops.clearDirty()
	}
	x.dirty = 0
}

func (x *City) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncableCityBaseInfo struct {
	Positions Vector_List
	Troops Int32_Empty_Map
	BuildInfo []byte
}

type dirtyParentFunc_CityBaseInfo func()

func (f dirtyParentFunc_CityBaseInfo) invoke() {
	if f == nil {
		return
	}
	f()
}

type CityBaseInfo struct {
	syncable syncableCityBaseInfo

	dirty uint64
	dirtyParent dirtyParentFunc_CityBaseInfo
}

func NewCityBaseInfo() *CityBaseInfo {
	x := new(CityBaseInfo)
	x.dirty = 1
	x.initPositions()
	x.initTroops()
	return x
}

func (x *CityBaseInfo) GetPositions() *Vector_List {
	return &x.syncable.Positions
}

func (x *CityBaseInfo) initPositions() {
	x.syncable.Positions.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 1)
	}
}

func (x *CityBaseInfo) GetTroops() *Int32_Empty_Map {
	return &x.syncable.Troops
}

func (x *CityBaseInfo) initTroops() {
	x.syncable.Troops.syncable = make(map[int32]struct{})
	x.syncable.Troops.dirtyParent = func() {
		x.markDirty(uint64(0x01) << 2)
	}
}

func (x *CityBaseInfo) GetBuildInfo() []byte {
	return x.syncable.BuildInfo
}

func (x *CityBaseInfo) SetBuildInfo(v []byte) {
	if v != nil || x.syncable.BuildInfo != nil {
		return
	}
	x.syncable.BuildInfo = v
	x.markDirty(uint64(0x01) << 3)
}

func (x *CityBaseInfo) DumpChange() *kdspb.CityBaseInfo {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.CityBaseInfo)
	if x.checkDirty(uint64(0x01) << 1) {
		m.Positions = x.syncable.Positions.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.Troops = x.syncable.Troops.DumpChange()
	}
	if x.checkDirty(uint64(0x01) << 3) {
		m.BuildInfo = x.syncable.BuildInfo
	}
	return m
}

func (x *CityBaseInfo) DumpFull() *kdspb.CityBaseInfo {
	m := new(kdspb.CityBaseInfo)
	m.Positions = x.syncable.Positions.DumpFull()
	m.Troops = x.syncable.Troops.DumpFull()
	m.BuildInfo = x.syncable.BuildInfo
	return m
}

func (x *CityBaseInfo) markAll() {
	x.dirty = uint64(0x01)
}

func (x *CityBaseInfo) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *CityBaseInfo) clearAll() {
	x.syncable.Positions.clearDirty()
	x.syncable.Troops.clearDirty()
	x.dirty = 0
}

func (x *CityBaseInfo) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	if x.dirty & uint64(0x01) << 1 != 0 {
		x.syncable.Positions.clearDirty()
	}
	if x.dirty & uint64(0x01) << 2 != 0 {
		x.syncable.Troops.clearDirty()
	}
	x.dirty = 0
}

func (x *CityBaseInfo) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type syncableVector struct {
	X int32
	Y int32
}

type dirtyParentFunc_Vector func()

func (f dirtyParentFunc_Vector) invoke() {
	if f == nil {
		return
	}
	f()
}

type Vector struct {
	syncable syncableVector

	dirty uint64
	dirtyParent dirtyParentFunc_Vector
}

func NewVector() *Vector {
	x := new(Vector)
	x.dirty = 1
	return x
}

func (x *Vector) GetX() int32 {
	return x.syncable.X
}

func (x *Vector) SetX(v int32) {
	if v == x.syncable.X {
		return
	}
	x.syncable.X = v
	x.markDirty(uint64(0x01) << 1)
}

func (x *Vector) GetY() int32 {
	return x.syncable.Y
}

func (x *Vector) SetY(v int32) {
	if v == x.syncable.Y {
		return
	}
	x.syncable.Y = v
	x.markDirty(uint64(0x01) << 2)
}

func (x *Vector) DumpChange() *kdspb.Vector {
	if x.checkDirty(uint64(0x01)) {
		return x.DumpFull()
	}
	m := new(kdspb.Vector)
	if x.checkDirty(uint64(0x01) << 1) {
		m.X = x.syncable.X
	}
	if x.checkDirty(uint64(0x01) << 2) {
		m.Y = x.syncable.Y
	}
	return m
}

func (x *Vector) DumpFull() *kdspb.Vector {
	m := new(kdspb.Vector)
	m.X = x.syncable.X
	m.Y = x.syncable.Y
	return m
}

func (x *Vector) markAll() {
	x.dirty = uint64(0x01)
}

func (x *Vector) markDirty(n uint64) {
	if x.dirty & n == n {
		return
	}
	x.dirty |= n
	x.dirtyParent.invoke()
}

func (x *Vector) clearAll() {
	x.dirty = 0
}

func (x *Vector) clearDirty() {
	if x.dirty == 0 {
		return
	}
	if x.dirty & uint64(0x01) != 0 {
		x.clearAll()
		return
	}
	x.dirty = 0
}

func (x *Vector) checkDirty(n uint64) bool {
	return x.dirty & n != 0
}

type dirtyParentFunc_Vector_List func()

func (f dirtyParentFunc_Vector_List) invoke() {
	if f == nil {
		return
	}
	f()
}

type Vector_List struct {
	syncable []*Vector

	dirty bool
	dirtyParent dirtyParentFunc_Vector_List
}

func (x *Vector_List) Len() int {
	return len(x.syncable)
}

func (x *Vector_List) Get(i int) *Vector {
	return x.syncable[i]
}

func (x *Vector_List) Set(i int, v *Vector) {
	if v != nil && v.dirtyParent != nil {
		panic("the component should be removed or evicted from its original place first")
	}
	if v == x.syncable[i] {
		return
	}
	if x.syncable[i] != nil {
		x.syncable[i].dirtyParent = nil
	}
	x.syncable[i] = v
	if v != nil {
		v.dirtyParent = func() {
			x.markDirty()
		}
		v.dirty |= uint64(0x01)
	}
	x.markDirty()
}

func (x *Vector_List) Append(v ...*Vector) {
	for i := range v {
		if v[i] != nil && v[i].dirtyParent != nil {
			panic("the component should be removed or evicted from its original place first")
		}
	}
	if len(v) == 0 {
		return
	}
	x.syncable = append(x.syncable, v...)
	for i := range v {
		if v[i] != nil {
			v[i].dirtyParent = func() {
				x.markDirty()
			}
			v[i].dirty |= uint64(0x01)
		}
	}
	x.markDirty()
}

func (x *Vector_List) Insert(i int, v ...*Vector) {
	for j := range v {
		if v[j] != nil && v[j].dirtyParent != nil {
			panic("the component should be removed or evicted from its original place first")
		}
	}
	if len(v) == 0 {
		return
	}
	x.syncable = slices.Insert(x.syncable, i, v...)
	for j := range v {
		if v[j] != nil {
			v[j].dirtyParent = func() {
				x.markDirty()
			}
			v[j].dirty |= uint64(0x01)
		}
	}
	x.markDirty()
}

func (x *Vector_List) Delete(i, j int) {
	r := x.syncable[i:j:len(x.syncable)]
	for k := range r {
		if r[k] != nil {
			r[k].dirtyParent = nil
		}
	}
	if i == j {
		return
	}
	x.syncable = slices.Delete(x.syncable, i, j)
	x.markDirty()
}

func (x *Vector_List) Replace(i, j int, v ...*Vector) {
	for k := range v {
		if v[k] != nil && v[k].dirtyParent != nil {
			panic("the component should be removed or evicted from its original place first")
		}
	}
	r := x.syncable[i:j:len(x.syncable)]
	for k := range r {
		if r[k] != nil {
			r[k].dirtyParent = nil
		}
	}
	if i == j && len(v) == 0 {
		return
	}
	x.syncable = slices.Replace(x.syncable, i, j, v...)
	for k := range v {
		if v[k] != nil {
			v[k].dirtyParent = func() {
				x.markDirty()
			}
			v[k].dirty |= uint64(0x01)
		}
	}
	x.markDirty()
}

func (x *Vector_List) Reverse() {
	if len(x.syncable) < 2 {
		return
	}
	slices.Reverse(x.syncable)
	x.markDirty()
}

func (x *Vector_List) All() iter.Seq2[int, *Vector] {
	return slices.All(x.syncable)
}

func (x *Vector_List) Backward() iter.Seq2[int, *Vector] {
	return slices.Backward(x.syncable)
}

func (x *Vector_List) Values() iter.Seq[*Vector] {
	return slices.Values(x.syncable)
}

func (x *Vector_List) DumpChange() []*kdspb.Vector {
	return x.DumpFull()
}

func (x *Vector_List) DumpFull() []*kdspb.Vector {
	var m []*kdspb.Vector
	for _, v := range x.syncable {
		m = append(m, v.DumpChange())
	}
	return m
}

func (x *Vector_List) markDirty() {
	if x.dirty {
		return
	}
	x.dirty = true
	x.dirtyParent.invoke()
}

func (x *Vector_List) clearDirty() {
	for k := range x.syncable {
		if x.syncable[k] != nil {
			x.syncable[k].clearDirty()
		}
	}
	x.dirty = false
}